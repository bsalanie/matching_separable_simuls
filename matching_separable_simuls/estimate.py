# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_estimate.ipynb.

# %% auto 0
__all__ = ['legendre_polynomials', 'quantile_transform', 'generate_bases']

# %% ../nbs/01_estimate.ipynb 3
import sys
import numpy as np
from fastcore.test import test_close, test_eq
from typing import Tuple, List



# %% ../nbs/01_estimate.ipynb 4
def legendre_polynomials(
    x: np.ndarray,      # points where the polynomials are to be evaluated
    max_deg: int,       # maximum degree
    a: float = -1.0,    # start of interval, classically -1
    b: float = 1.0,      # end of interval, classically 1
    no_constant: bool = False       # if True, delete the constant polynomial
    ) -> np.ndarray:    # returns an array of (max_deg+1) arrays of the shape of x
    """ evaluates the Legendre polynomials over x in the interval [a, b] """
    if a > np.min(x):
        sys.exit(f"legendre_polynomials: points below start of interval")
    if b <  np.max(x):
        sys.exit(f"legendre_polynomials: points above end of interval")
    p =np.zeros((x.size, max_deg + 1))
    p0 = np.ones_like(x)
    x_transf = 2.0*(x-a)/(b-a)-1.0
    p1 = x_transf
    p[:, 0] = np.ones_like(x)
    p[:, 1] = x_transf
    for deg in range(2, max_deg+1):
        p2 = (2*deg-1)*(p[:, deg-1]*x_transf)-(deg-1)*p[:, deg-2]
        p[:, deg] = p2/deg
    polys_p = p[:, 1:] if no_constant else p
    return polys_p
        
    

def quantile_transform(
    v: np.ndarray        # a vector of counts
    ) -> np.ndarray:     # the corresponding quantiles
    """ transform a vector of counts into the corresponding quantiles """
    n = v.size
    q = np.zeros(n)
    for i in range(n):
        q[i] = np.sum(v <= v[i])/(n+1)
    return q
        


def generate_bases(
    nx: np.ndarray,                              # the numbers of men of each type
    my: np.ndarray,                              # the numbers of women of each type
    degrees: List[Tuple[int, int]],              # the list of degrees for polynomials in `x` and `y`
    ) -> Tuple[np.ndarray, List[str]]:           # the matrix of base functions and their names
    """ generates the bases for a semilinear specification """
    n_bases = 3 + len(degrees)
    n_types_men, n_types_women = nx.size, my.size
    types_men, types_women = np.arange(n_types_men), np.arange(n_types_women)
    base_funs = np.zeros((n_types_men, n_types_women, n_bases))
    base_names = [None]*n_bases
    base_funs[:, :, 0] = 1.0
    base_names[0] = "1"
    for y in types_women:
        base_funs[:, y, 1] = np.where(types_men > y, 1.0, 0.0)
        base_funs[:, y, 2] = np.where(types_men > y, types_men-y, 0)
    base_funs[:, :, 2] /= (n_types_men + n_types_women)/2
    base_names[1] = "1(x>y)"
    base_names[2] = "max(x-y,0)"
    # we quantile-transform nx and my
    q_nx = quantile_transform(nx)
    q_my = quantile_transform(my)
    # and we use the Legendre polynomials on [0,1]
    max_deg_x = max(degree[0] for degree in degrees)
    max_deg_y = max(degree[1] for degree in degrees)
    polys_x = legendre_polynomials(q_nx, max_deg_x, a=0)
    polys_y = legendre_polynomials(q_my, max_deg_y, a=0)
    i_base = 3
    for deg_x, deg_y in degrees:
        poly_x = polys_x[:, deg_x]
        poly_y = polys_y[:, deg_y]
        base_funs[:, :, i_base] = np.outer(poly_x, poly_y)
        base_names[i_base] = f"x^{deg_x} * y^{deg_y}"
        i_base += 1
    return base_funs, base_names

            
    
    
    
    
    
