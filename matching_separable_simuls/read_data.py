# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_read_data.ipynb.

# %% auto 0
__all__ = ['get_root_dir', 'read_margins', 'read_marriages', 'reshape_varcov', 'rescale_mus', 'remove_zero_cells']

# %% ../nbs/00_read_data.ipynb 4
import operator
from fastcore.test import *
from sys import platform
import numpy as np
from pathlib import Path
from typing import Tuple

from cupid_matching.matching_utils import Matching, _compute_margins, _get_singles

# %% ../nbs/00_read_data.ipynb 5
def get_root_dir(
                    # no argument
    ) -> Path:      # the package directory
    """ returns the package directory """
    root_dir = Path.cwd().parent
#     if platform in ["linux", "linux2"]:        # we are deploying
#         root_dir = Path.cwd().parent
    return root_dir

# %% ../nbs/00_read_data.ipynb 6
def read_margins(
    data_dir: Path      # the data directory
    ) -> Tuple[np.ndarray, np.ndarray]: 
    """reads and returns the margins for men and for women """
    nx = np.loadtxt(data_dir / "nx70n.txt")
    my = np.loadtxt(data_dir / "my70n.txt")
    return nx, my

def read_marriages(
    data_dir: Path      # the data directory
    ) -> Tuple[np.ndarray, np.ndarray]: 
    """ reads and returns the marriages and the variances"""
    muxy = np.loadtxt(data_dir / "muxy70nN.txt")
    varmus = np.loadtxt(data_dir / "varmus70nN.txt")
    return muxy, varmus

# %% ../nbs/00_read_data.ipynb 7
def reshape_varcov(
    varmus: np.ndarray,      #  muxy row major, then  mux0, then mu0y packed in both dimensions
    mus: Matching,           #  the original Matching
    n_households: int        #  the number of households we want
) -> tuple[np.ndarray]:      #  the 6 constituent blocks of the normalized variance-covariance
    """ splits the variance-covariance matrix 
    and renomalizes for a requested total number of households
    """
    muxy, mux0, mu0y, *_ = mus.unpack()
    ncat_men, ncat_women = muxy.shape
    n_prod_categories = ncat_men * ncat_women
    # first we reshape
    varmus_xyzt = varmus[:n_prod_categories, :n_prod_categories]
    varmus_xyz0 = varmus[:n_prod_categories,
                                n_prod_categories:(n_prod_categories + ncat_men)]
    varmus_xy0t = varmus[:n_prod_categories,
                                (n_prod_categories + ncat_men):]
    varmus_x0z0 = varmus[n_prod_categories:(n_prod_categories + ncat_men),
                                n_prod_categories:(n_prod_categories + ncat_men)]
    varmus_x00y = varmus[n_prod_categories:(n_prod_categories + ncat_men), 
                         (n_prod_categories + ncat_men):]
    varmus_0y0t = varmus[(n_prod_categories + ncat_men):, 
                         (n_prod_categories + ncat_men):]
    varcovs = (varmus_xyzt, varmus_xyz0, varmus_xy0t,
              varmus_x0z0, varmus_x00y, varmus_0y0t)
    # then we rescale
    n_households_mus = np.sum(muxy) + np.sum(mux0) + np.sum(mu0y)
    rescale_factor = n_households/n_households_mus
    rescale_factor2 =  rescale_factor*rescale_factor
    varcovs = tuple(v*rescale_factor2 for v in varcovs)
    return varcovs

# %% ../nbs/00_read_data.ipynb 9
def rescale_mus(
    mus: Matching,         # muxy, mux0, mu0y
    n_households: int | float    # the number of households we want
) -> Matching:  # the normalized Matching after rescaling
    """ normalizes the marriages and margins to a requested total number of households"""
    muxy, mux0, mu0y, nx, my = mus.unpack()
    n_households_mus = np.sum(muxy) + np.sum(mux0) + np.sum(mu0y)
    rescale_factor = n_households/n_households_mus
    muxy_norm = muxy * rescale_factor
    nx_norm = nx * rescale_factor
    my_norm = my  * rescale_factor
    mus_norm = Matching(muxy_norm, nx_norm, my_norm)
    return mus_norm

  

# %% ../nbs/00_read_data.ipynb 11
def _get_zeros_mu(
    mu: np.ndarray,
    eps: float=1e-9
) -> Tuple[bool, np.ndarray, float]:
    mu_size = mu.size
    nonzero_mu = mu[mu > eps]
    min_nonzero = np.min(nonzero_mu)
    n_zeros_mu = mu_size - nonzero_mu.size
    mu_has_zeros = (n_zeros_mu > 0)
    return mu_has_zeros, mu_size, min_nonzero
    
    
def remove_zero_cells(
    mus: Matching,         # muxy, mux0, mu0y, n, m
    coeff: int = 100 # default scale factor for delta
) -> Matching:  # the transformed muxy, mux0, mu0y, nx, my
    """add small number `delta` to 0-cells to avoid numerical issues"""
    muxy, mux0, mu0y, *_ = mus.unpack()
    zeros_muxy, muxy_size, min_muxy = _get_zeros_mu(muxy)
    zeros_mux0, mux0_size, min_mux0 = _get_zeros_mu(mux0)
    zeros_mu0y, mu0y_size, min_mu0y = _get_zeros_mu(mu0y)
    some_zeros = (zeros_muxy or zeros_mux0 or zeros_mu0y)
    if not some_zeros:
        return mus
    else:
        delta = min(min_muxy, min_mux0, min_mu0y)/coeff
        muxy_fixed = muxy.astype(float)
        mux0_fixed = mux0.astype(float)
        mu0y_fixed = mu0y.astype(float)
        n_cells = 0
        if zeros_muxy:
            muxy_fixed += delta
            n_cells += muxy_size
        if zeros_mux0:
            mux0_fixed += delta
            n_cells += mux0_size
        if zeros_mu0y:
            mu0y_fixed += delta
            n_cells += mu0y_size
        n_households = np.sum(muxy)+np.sum(mux0)+np.sum(mu0y)
        scale_factor = n_households/(n_households+delta*n_cells)
        muxy_fixed *= scale_factor
        mux0_fixed *= scale_factor
        mux0_fixed *= scale_factor
        nx_fixed, my_fixed = _compute_margins(muxy_fixed, mux0_fixed, mu0y_fixed)
        mus_fixed = Matching(muxy_fixed, nx_fixed, my_fixed)
        return mus_fixed
